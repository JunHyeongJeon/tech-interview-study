# 3. Operating System
**:book: Contents**

- [OS란 무엇이며, 핵심 기능은?](#OS개념과-핵심-기능)
- [부팅이 되는 과정을 설명하시오.](#부팅이-되는-과정)
- [프로세스의 5가지 상태에 대해 설명하시오.](#프로세스의-5가지-상태)
- [메모리 계층 구조를 설명하시오.](#메모리-계층-구조)
- [캐시와 버퍼의 차이점은?](#캐시와-버퍼의-차이점)

* [세마포어와 뮤텍스란? 차이점은 무엇인가?](#세마포어와 뮤텍스란?-차이점은-무엇인가?)			
* [메모리 단편화, 페이징, 세그멘테이션](#메모리-단편화,-페이징,-세그멘테이션)			
* [선점스케줄링과 비선점스케줄링, 해당하는 알고리즘 한개씩](#선점스케줄링과-비선점스케줄링,-해당하는-알고리즘-한개씩)				
* [문맥교환이란?](#문맥교환이란?)			
* [PCB란?](#PCB란?)


* [가상메모리란?](#가상메모리란?)
* [Deadlock이란?](#Deadlock이란?)
* [프로세스의 메모리구조?](#프로세스의-메모리구조?)
* [thrashing이란?](#thrashing이란?)
* [프로세스간 통신하는 방법은?](#프로세스간-통신하는-방법은?)
---

### OS개념과 핵심 기능
**운영체제란**
H/W와 S/W 사이에서 둘을 효율적으로 운영하고 관리하여
사용자가 컴퓨터를 편리하게 사용할수 있도록 하는 프로그램

**운영체제 기능**
1. 자원관리
- 컴퓨터 시스템을 구성하는 cpu, 기억장치, 주변장치, data등 컴퓨터 자원을 관리한다

2. 프로세스 관리
- 프로세스와 쓰레드 스케줄링, 프로세스 생성과 제거, 프로세스 시작, 정지, 재수행
- 프로세스 동기화 및 통신, 주기억 장치 관리를 위해 주기억장치 관리자와 협력

3. 기억장치 관리
- 메모리 상태 추적, 메모리 할당 및 회수, 가상기억장치 및 페이징 장치 관리, 장치 관리자 또는 파일 관리자와 협력

4. 입출력 장치 관리
- 입출력 장시의 스케줄 관리, 각종 주변장치의 스케줄링 및 관리

5. 파일 관리
- 파일 생성과 삭제, 변경 유지들의 관리
- 정보의 위치, 사용여부와 상태 등을 추적 관리

> <https://flearning-blog.tistory.com/16>

> :arrow_double_up:[Top](#3-os)    :leftwards_arrow_with_hook:[Back](https://github.com/devham76/tech-interview-studyw#3-os)    :information_source:[Home](https://github.com/devham76/tech-intervie-studyw#tech-interview)

### 부팅이 되는 과정
> <https://neos518.tistory.com/113>

> :arrow_double_up:[Top](#3-os)    :leftwards_arrow_with_hook:[Back](https://github.com/devham76/tech-interview-studyw#3-os)    :information_source:[Home](https://github.com/devham76/tech-intervie-studyw#tech-interview)

### 프로세스의 5가지 상태
![프로세스 상태](https://user-images.githubusercontent.com/55946791/80938240-559b8600-8e13-11ea-9176-a121491a0fb3.jpg)
1. 생성 : 프로세스 생성 상태 , pcb를 할당받은 상태
2. 실행 : 프로세스가 cpu에 할당되어 실행 중인 상태
3. 준비 : 프로세스가 cpu에 할당되기를 기다리는 상태
4. 대기 : 보류(block)라고도 하며, 프로세스가 입출력이나 이벤트릴 기다리는 상태
5. 종료 : 프로세스 종료 상태

> <https://rebas.kr/852>

> :arrow_double_up:[Top](#3-os)    :leftwards_arrow_with_hook:[Back](https://github.com/devham76/tech-interview-studyw#3-os)    :information_source:[Home](https://github.com/devham76/tech-intervie-studyw#tech-interview)

### 메모리 계층 구조
![메모리 계층](https://user-images.githubusercontent.com/55946791/80938438-128de280-8e14-11ea-8207-95cb98d94303.jpg)

**메모리 종류**
1. Main 메모리 : 램 (RAM)
2. Register : cpu안에 내장되어 있어 연산을 위한 저장소 제공
3. Cache : cpu와 RAM사이에서 중간 저장소 역할
4. Hard Disk와 이외 장치 : 하드디스크, I/O장치 등
(* CPU와 거리가 가까울수록, 빠르고 용량이 작다. 멀수록, 느리고 용량이 크다)

**데이터 이동**
- 프로그램의 실행을 위해 하드디스크에 있는 내용은 메인 메모리로 이동한다
- 메인 메모리에 있는 일부 데이터도 실행을 위해 L2캐시로 이동한다
- L2캐시에 있는 데이터 일부는 L1캐시로 이동한다
- L1캐시에 있는 데이터 중 연산이 필요한 데이터는 레지스터로 이동한다.

> <https://dakuo.tistory.com/126>

> :arrow_double_up:[Top](#3-os)    :leftwards_arrow_with_hook:[Back](https://github.com/devham76/tech-interview-studyw#3-os)    :information_source:[Home](https://github.com/devham76/tech-intervie-studyw#tech-interview)

### 캐시와 버퍼의 차이점

**캐시**
- 이전에 접근한 데이터를 빠르게 접근하기 위해 임시로 저장
- 교체 알고리즘에 따라 삭제될수도 안될수도있다
- 캐시는 어떤 원리로 저장되나요? __지역성__ / (시간, 공간)
	- 한번 참조되면 가까운 미래에 또 사용될수있다
	- 참조된 메모리에 가까운 곳에 있는 데이터가 또 사용될수있다

**버퍼**
- 전송전에 임시로 저장
- 미리 출력할것을 버퍼에 담아서 성능 빠르게
- 사용후에 바로 삭제 된다

> :arrow_double_up:[Top](#3-os)    :leftwards_arrow_with_hook:[Back](https://github.com/devham76/tech-interview-studyw#3-os)    :information_source:[Home](https://github.com/devham76/tech-intervie-studyw#tech-interview)



### 세마포어와 뮤텍스란? 차이점은 무엇인가?

**세마포어와 뮤텍스 정의**
- 여러 프로세스나 쓰레드가 __공유 자원에 접근하는 것을 제어하기__ 위한 방법
- __병행 처리를 위한 프로세스 동기화 기법__

**세마포어**
- 세마포어 변수, wait()함수, signal()함수가 있다.
- 세마포어 변수 : 공유 가능한 자원의 수
- wait() : 세마포어 값을 감소 시킨다. 음수가되면 호출한 프로세스는 블록된다.
- signal() : 실행되던 프로세스가 종료되어, 세마포어 값을 증가시킨다. 만약 값이 0이거나 음수면, swmWait연산에 의해 블록된 프로세스를 wake_up한다
<br>
- 세마포어 종류 : binary 세마포어(세마포어가 0또는1만허용), counting 세마포어(0또는1이상의수를 가질수있다)

**뮤텍스**
- 초기값을 1과0으로 가진다
- 임계구역에 들어갈때 락(lock)을 걸어 다른 프로세스(or 쓰레드)가 접근하지 못하도록하고
- 임계구역에서 나올때 해당 락을 해제(unlock)한다.

**뮤텍스와 세마포어의 차이**
- 세마포어는 공유 자원에 __세마포어의 변수만큼 프로세스(or 쓰레드)가__ 접근할 수 있다
- 반면에 뮤텍스는 __오직 1개만의 프로세스(or 쓰레드)만 접근 가능
<br>
- 현재 수행중인 프로세스가 아닌 __다른 프로세스가 세마포어 해제__ 가능
- 뮤텍스는 __락(lock)을 획득한 프로세스가 반드시 그 락을 해제__ 해야 한다.

> [참고](https://velog.io/@conatuseus/OS-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4)

> :arrow_double_up:[Top](#3-os)    :leftwards_arrow_with_hook:[Back](https://github.com/devham76/tech-interview-studyw#3-os)    :information_source:[Home](https://github.com/devham76/tech-intervie-studyw#tech-interview)

### 메모리 단편화, 페이징, 세그멘테이션

- 세그멘테이션-가변적으로 자른다 / 장점,단점
- 페이지-고정된 크기로 자른다 / 장점, 단점
- 물리메모리- 프레임
- 가상메모리- 페이지

**메모리 단편화**
- 메모리의 공간이 작은 조각으로 나뉘어져서 __사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태__

**외부 단편화**
- 메모리가 할당되고 해제되는 작업이 반복되면서 작은 메모리가 중간중간에 존재
- 이 때 중간에 생긴 사용하지 않은 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할수 없는 상황

**내부 단편화**
- __프로세스가 필요한 양보다 더 큰 메모리가 할당 되어서__ 프로세스에서 사용하는 메모리가 낭비되는 상황


**페이징 기법**
- 외부 단편화 해결, 내부 단편화 존재
- 가상메모리를 __같은 크기의 블록으로 나눈것을 페이지__ 라고한다.
- 물리메모리를 같은 크기의 블록으로 나눈것을 프레임이라고 한다.
<br>
- 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법.
- 연속적이지 않은 공간도 활용할수 있기 때문에 외부 단편화 문제를 해결 할 수 있다.

- 페이지 테이블이란 ?

**세그멘테이션 기법**
- 내부 단편화 해결, 외부 단편화 존재
- 가상메모리를 __서로 크기가 다른 논리적 단위인 세크멘트로 분할해서 메모리를 할당__ 하여 실제 메모리 주소로 변환을 하게 된다.
- 각 세그먼트는 __연속적인 공간에 저장__ 되어 있다.
- 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈공간을 찾아 할당하는 기법.

> [참고](https://jeong-pro.tistory.com/91)

> :arrow_double_up:[Top](#3-os)    :leftwards_arrow_with_hook:[Back](https://github.com/devham76/tech-interview-studyw#3-os)    :information_source:[Home](https://github.com/devham76/tech-intervie-studyw#tech-interview)

### 선점스케줄링과 비선점스케줄링, 해당하는 알고리즘 한개씩

- 선점 알고리즘 : 어떤 프로세스가 CPU를 할당 받아 실행 중이더라도 OS가 CPU를 강제로 빼앗을 수 있다.

**비선점 알고리즘**
- FCF
- SJF(Shortest Job First, 실생 시간이 가장 짧은 작업부터)
- HRN(Highest Response Ratio Next, 최고 응답률 우선 스케줄링)

**선점 알고리즘**
- RR(Round Robin) : 할당받은 시간(타임 슬라이스)동안 작업 하다가 작업 미완료시 준비 큐의 맨뒤로 간다.
- SRT(Shortest Remaining Time) : SJF + RR 방식
  - 최소 잔류 시간 우선 스케줄링
  - 나은 시간이 적은 프로세스에 CPU를 먼저 할당
- 다단계 큐 스케줄링
  - 우선순위에 따라 준비 큐가 여러개
  - 상단의 큐에 잇는 모든 프로세스가 종료되야 다음 우선순위 큐의 작업이 시작된다.
- 다단계 피드백 큐 스케줄링
  - __우선순위가 낮은 프로세스에 불리한 다단계 큐 스케줄링__ 을 보완한 방식
  - CPU를 사용하고 난 프로세스는 원래 큐로 돌아가지않고, 우선순위가 하나 낮은 큐의 끝으로 들어간다.
  - 우선순위를 낮춤으로써, 다단계 큐에서 우선순위가 낮은 프로세스의 실해이 연기되는 문제를 완화한다.

**둘 다 가능**
- 우선순위 스케줄링
  - 프로세스는 중요도에 따라 우선순위를 갖는다.
  - 일정 시간마다 우선순위가 변하거나 고정되거나

> :arrow_double_up:[Top](#3-os)    :leftwards_arrow_with_hook:[Back](https://github.com/devham76/tech-interview-studyw#3-os)    :information_source:[Home](https://github.com/devham76/tech-intervie-studyw#tech-interview)

### 문맥교환이란?
- CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다.
- 두 프로세스의 PCB를 교환 하는 작업
- 현재까지의 작업 상태를 저장하고 다음 작업에 필요한 각종 상태, 데이터를 읽어오는 작업
> :arrow_double_up:[Top](#3-os)    :leftwards_arrow_with_hook:[Back](https://github.com/devham76/tech-interview-studyw#3-os)    :information_source:[Home](https://github.com/devham76/tech-intervie-studyw#tech-interview)

### PCB란?
- __프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료구조__
- __각 프로세스가 생성될 때마다 고유의 PCB가__ 생성되고, 완료되면 제거된다.
<br>
- 프로세스는 CPU를 할당받아 작업을 처리하다가, CPU를 선점 당하게 되면 진행 중이던 작업 내용을 PCB에 저장하고 CPU를 반환한다.
- 이후에 다시 CPU를 할당받으면 PCB로 부터 진행이 끊겼던 부분에서 다시 작업을 실행한다
- 프로세스 식별자, 상태, PC(프로그램 카운터, 다음 실행할 명령의 주소 가르킴), 메모리 관리 정보 등을 가지고 있다.

> :arrow_double_up:[Top](#3-os)    :leftwards_arrow_with_hook:[Back](https://github.com/devham76/tech-interview-studyw#3-os)    :information_source:[Home](https://github.com/devham76/tech-intervie-studyw#tech-interview)

### 가상메모리란?
실제 시스템에 있는 물리적인 메모리의 크기에 상관 없이 가상 공간을 프로세스에게 제공합니다. 이런 가상 메모리는 프로세스 전체가 메모리에 적재되지 않아도 프로세스의 실행이 가능하도록 합니다.

> [참고](https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC)

- 가상메모리 어떻게 구현하나요 ? - 페이징, 세크멘테이션

### Deadlock이란?

- 교착 상태란 두 개 이상의 작업이 서로 __상대방의 작업이 끝나기 만을 기다리고__ 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 가리킨다
- 멀티프로세스나 멀티쓰레드 환경에서 __여러 프로세스들이 한정된 자원을__ 사용하기 때문에 발생할 수 있다


**데드락 발생 조건**
- 모두 충족해야 발생

1. 상호배제
	- 자원은 한 번에 한 프로세스만이 사용할수 있다
2. 점유대기 (Hold and wait)
	- 자원을 할당받은 상태에서 다른 자원을 기다리는 상태
3. 비선점
	- 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺏을수 없다
4. 순환 대기 (Circular wait)
	- 점유와 대기를 하는 프로세스 간의 관계가 원을 이룬다.
	- 점유와 대기를 하는 프로세스들이 서로 방해하는 방향이 원을 이루면, 프로세스들이 서로 양보하지 않기 때문에 교착상태 발생

**데드락 처리 - 1.예방**
- 교착 상태 발생 조건 중 하나를 제거함으로써 해결
	1) 상호배제 부정 : 여러 개의 프로세스가 공유 자원 사용가능 (보호해야할 자원을 공유하기힘들다)
	2) 점유대기 부정 : 자원을 점유한상태에서 다른 자원 기다리지 못함. (전부 할당 or 아예할당x)
	3) 비선점 부정 : 자원을 빼앗을 수 있도록 만든다 (우선순위가 낮은 프로세스 기아현상)
	4) 순환대기 부정 : 모든 자원에 숫자를 부여하고 숫자가 큰 방향으로만 자원할당(번호 부여 방식 선정 어려움)
- 문제점 :
	- 자원을 보호하기 위해 1.상호배제, 3.비선점을 예방하기 어렵고
	- 2.점유대기, 4.순환대기는 프로세스 작업 방식을 제한하고 자원을 낭비한다

**데드락 처리 - 2.회피**
- 교착 상태가 발생하면 피하는 방법
- 교착 상태가 발생하지 않는 범위 내에서만 자원할당, 교착 상태 발생하는 범위에서 프로세스 대기
- 교착 상태 예방보다 좀 더 유연하다.

**은행원 알고리즘 (Banker’s Algorithm)**
- 은행이 대출 해주는 방식. 즉, 대출 금액이 대출 가능한 범위이면(안정 상태) 허용, 그렇지 않으면 거부.
- 안정 상태에 있으면 자원을 할당하고, 그렇지 않으면 다른 프로세스들이 자원을 해지할 때까지 대기함
<br>
- 최대 자원 : 자신이 사용할 자원의 최대수
- 할당 자원 : 할당된 자원수
- 기대 자원 : 최대자원 - 할당 자원
- 가용 자원 : 남은 자원의 수
<br>
- 문제점 :
	- 모든 프로세스가 __자신이 사용할 모든 자원을 미리 알기 어렵다__
	- 시스템의 전체 자원 수는 유동적이므로 전체 자원 수를 고정하기 어렵다
	- 자원 낭비 ; 실제로 교착상태가 발생하지 않았지만 발생할 것이라고 예상하여, _프로세스에 자원 할당하는 것에 제약_ 을 둔다.

**데드락 처리 - 3.탐지**
- os가 프로세스의 작업을 관찰하면서 데드락 발생 여부를 계속 주시

**타임아웃**
- __일정 시간 동안 작업이 진행되지 않은 프로세스를__ 데드락 발생한것으로 간주하여 처리
- 자원 할당 그래프를 이용하는것보다 쉽기 때문에 선호한다

**자원 할당 그래프**
- 자원할당 그래프를 통해 프로세스가 어떤 자원을 사용, 기다리는지 알 수 있다
- 장점 : 프로세스의 작업 방식을 제한하지 않으면서 교착상태를 정확하게 파악
- 단점 : 자원 할당 그래프를 유지, 갱신, 사이클 검수하면서 __오버헤드가 발생__
	- 추가 작업을 줄이기 위해 자원 할당시마다 사이클 검사X, 일정 시간마다 검사하는 방법도 있음



**데드락 처리 - 4.회복**
- 데드락 발생 시킨 프로세스 종료하거나 할당된 자원을 해제 하여 회복하는 것을 의미
1. 교착상태 발생시킨 프로세스 동시에 종료
2. 교착상태 발생시킨 프로세스 중 하나를 골라 순서대로 종료
	- 우선순위 낮은 프로세스 종료
	- 작업 시간 짧은 프로세스 종료
	- 자원을 많이 사용하는 프로세스 종료

> [참고](https://jwprogramming.tistory.com/12)
> [참고 - 쉽게 배우는 운영체제]

### 프로세스의 메모리구조?

![메모리 구조](https://user-images.githubusercontent.com/55946791/81517248-423d6d00-9375-11ea-9cfe-84f20b7b4740.jpg)
- 메모리 영역은 크게 두가지로 나눌 수 있는데 컴파일시 크기가 고정되는 code, data, bss 영역과 실행시 메모리가 할당되었다 반납되는 heap, stack영역으로 나눌 수 있다.

1. 메모리 할당이 고정되는 영역 (compile시 결정)
	* code영역
		- 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 함수, 제어문, 상수 등이 여기에 지정된다.

	* data 영역 & BSS
		- data 영역은 BSS와 함께 묶어서 데이터 영역으로 칭하기도 하는데 이는 전역변수와 static변수가 지정되는 영역이다.
		- 초기화 되지 않은 전역변수들은 BSS에 지정된다.
    - data :초기값 있는 전역밴수, 배열, static으로 선언된 변수
    - bss : 초기값 없는 전역변수, 배열, static으로 선언된 변수

2. 실행 중에 메모리를 할당하는 영역(할당과 반납이 이루어짐) (runtime시 결정)
	* HEAP 영역
		- malloc(), calloc() 등으로 프로그래머가 자율적으로 메모리 크기를 할당할 수 있는 영역이다.
		- 위의 함수들은 free()함수로 할당된 영역을 반납해줘야하므로 동적할당 영역에 속한다.

	* STACK 영역
		- 지역변수가 할당되는 영역으로 함수가 호출되면 할당되었다 함수의 종료시 반납되는 영역이다.


**메모리 오버플로우**
- 위의 HEAP과 STACK영역은 사실 같은 공간을 공유한다.
- HEAP이 메모리 위쪽 주소부터 할당되면 STACK은 아래쪽 부터 할당되는 식이다.
- 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 HEAP OVERFLOW, STACK OVERFLOW라고 칭한다.

![메모리 오버플로우](https://user-images.githubusercontent.com/55946791/81517246-410c4000-9375-11ea-8d4e-fc9bb40d0387.jpg)

> [참고](https://zapiro.tistory.com/entry/%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD)

### thrashing이란?

- 가상메모리 크기 = 물리메모리 + 스왑영역 (하드디스크에 존재 or 멤리 관리자가 관리하는 영역)

**페이지 부재**
- 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황
![페이징 매칭](https://user-images.githubusercontent.com/55946791/81517925-613cfe80-9377-11ea-99e8-35dcce20fb79.jpg)
ex) 프로세스가 페이지 4를 요청 했을때, 페이지 테이블에 유효비트1, 주소 필드값 1 이므로 __메모리에 없고 스왑영역__ 에 있다. 이것을 페이지 부재라한다
- ex) 1,2,3 있을때 실제 메모리에 1,2 할당, 다음에 3할당하려면 빼고...반복

**Thrashing(쓰레싱)**
- 메모리에 페이지 부재율이 높은것, 심각한 성능 저하를 초래
- 하드디스크의 입출력이 너무 많아져서 잦은 페이지 부재로 작업이 멈춘 것 같은 상태
- 재료를 창고->도마 or 도마->창고 옮기는 작업이 많아, 요리 못하는 상태

**스레싱과 물리 메모리 크기**
- __멀티프로그래밍 정도__ : 동시에 실행하는 프로그램의 수
- 멀티프로그래밍 정도가 높으면 스레싱 발생
- 메모리가 꽉차면,
	- cpu가 작업하는 시간  < 스왑영역으로 페이지 보내고, 새로운 페이지 가져오는 작업 시간
	- cpu가 작업할 수 없는 상태 --> __스레싱 발생 지점__
![멀티 프로그래밍 정도와 스레싱](https://user-images.githubusercontent.com/55946791/81518391-d9f08a80-9378-11ea-8a2c-196ae4ac0417.png)

**물리 메모리 크기와 작업 속도**
- 물리 메모리 용량을 512MB->4GB로 늘리면, 스레싱 발생 지점 늦춰져서 성능 향상
- 물리 메모리 용량을 4GB -> 16GB로 늘리면 ? (물리 메모리가 작업하는데 충분한 크기면) 크기를 늘려도 작업 속도에 영향 미치지 X
	- 식탁 크기의 도마 -> 방 크기의 도마로 바꾼다해서 요리 시간이 빨라지지 X


**스레싱과 프레임 할당**
- 남아 있는 프레임을 실행 중인 프로세스에 적절히 나눠주는 정책
- 프로세스에 너무 적은 프레임 할당시, 페이지 부재 빈번
- 너무 많은 프레임 할당시, 페이지 부재 少, 메모리 낭비
--> 각 프로세스가 필요로 하는 최소한의 프레임 갯수를 보장해줘야 한다.

- 정적할당
- 동적할당

> [참고](https://jwprogramming.tistory.com/56)
> [참고 - 쉽게 배우는 운영체제]

### 프로세스간 통신하는 방법은?
- 파이프
  - 단방향 파이프를 통해서 데이터 전송(수신,송신 프로세스가 뭔지 알때 사용한다)
    - 부모프로세스가 같을때 사용한다
  - 네임드 파이프
    - 익명 파이프 단점 보완
    - 장점
- 공유메모리
  - 소켓을 통해서 통신
- 메세지큐
- 메모리맵

> [참고](http://blog.naver.com/PostView.nhn?blogId=bycho211&logNo=220985701140&parentCategoryNo=&categoryNo=13&viewDate=&isShowPopularPosts=true&from=search)
